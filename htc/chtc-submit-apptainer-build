#!/usr/bin/env python3

# ^-- replace shebang with "#!/usr/bin/python3" before deploying to CHTC.

# Written for Python 3.9

##############
# HTC Submit #
##############

import argparse
import os
import pwd

VERSION: str = "0.1"


def validate(args: argparse.Namespace) -> argparse.Namespace:
    """
    Checks that argument values are proper and ready to be used by the rest of the script.
    """

    # Check that `definition` is a valid file
    if not os.path.isfile(args.definition):
        if args.definition[-4:] == ".def":
            raise ValueError(f"Failed to locate definition file: {args.definition}")
        else:
            with_extension: str = f"{args.definition}.def"
            if os.path.isfile(with_extension):
                args.definition = with_extension
            else:
                raise ValueError(
                    f"Failed to locate definition file: {args.definition} NOR {with_extension}"
                )

    # If provided `definition` is a path, make `definition` a basename and put full path in `full_definition`
    args.full_definition = args.definition
    if "/" in args.definition:
        definition_basename: str = args.definition.split("/")[-1]
        args.definition = definition_basename

    # Generate `name` if `name` is not user-defined
    if (args.name is None) or (args.name == "<name>.sif"):
        if args.definition[-4:] == ".def":
            args.name = f"{args.definition[:-4]}.sif"
        else:
            args.name = f"{args.definition}.sif"

    # Check that `name` ends in `.sif`
    if args.name[-4:] != ".sif":
        args.full_name = f"{args.name}.sif"
    else:
        args.full_name = f"{args.name}"
        args.name = args.name[:-4]

    # Check that output destination `path` does not already contain `name`
    overwrite_warning: str = (
        f"WARNING: Output destination (may) already contain {args.full_name} - if so, it will be overwritten by this job!"
    )

    if args.path[-1] == "/":
        args.path = args.path[:-1]

    if (args.path[:4] in ["osdf", "file"]) or args.path[:7] == "pelican":
        print(overwrite_warning)

    destination = f"{args.path}/{args.full_name}"
    if os.path.isfile(destination):
        print(overwrite_warning)

    args.destination: str = destination

    return args


def generate_files(args: argparse.Namespace) -> tuple[str, str]:
    """
    Generates the files needed in order to submit the build job.
    """

    submit_file: str = "apptainer-build.sub"
    executable_file: str = "apptainer-build.sh"

    # Write `submit_file`
    submit_contents: str = f"""
job_name = build_{args.name}

universe = vanilla
log = $(job_name).log
batch_name = $(job_name)

executable = apptainer_build.sh
transfer_executable = True
arguments = {args.full_name}, {args.definition}
transfer_input_files = {args.full_definition}

transfer_output_files = {args.full_name}
transfer_output_remaps = "{args.full_name} = {args.destination}"

output = $(job_name).out
error = $(job_name).err
stream_output = True
stream_error = True

+IsBuildJob = True

request_cpus = 8
request_memory = 16GB
request_disk = 30GB

queue
"""

    with open(submit_file, "w") as f:
        f.write(submit_contents)

    # Write `executable_file`
    # Following definitions are used to include literal {} in the f-string block
    #   without using escapes (`\`) in the block, which the black formatter does not agree with
    bash_arg1 = "${1}"
    bash_arg2 = "${2}"
    bash_container_name = "${container_name}"
    bash_container_definition = "${container_definition}"
    bash_container_shortname = "${container_name::-4}"

    # fmt: off
    executable_contents: str = (
        f"""#!/bin/bash

# Read arguments from submit file
container_name={bash_arg1}
container_definition={bash_arg2}

# Print location of build (useful for troubleshooting)
echo -e "Building container {bash_container_name} on $(hostname).\\n"

# Miscellaneous setup things; typically not required, but erring on the safe side.
export PATH
chmod 777 ./tmp

# The actual build command. Piped into `tee` so that messages are streamed to build_{bash_container_shortname}.out
apptainer build --bind ./tmp:/tmp {bash_container_name} {bash_container_definition} 2>&1 | tee {bash_container_shortname}.log

# If running the build command manually, could use this instead:
#    apptainer build --bind ./tmp:/tmp {bash_container_name} {bash_container_definition}

# Grab exit code from the build command
exit_code="$PIPESTATUS"

# Check if container built successfully
if [ ! -f "{bash_container_name}" ] || [[ "$exit_code" != "0" ]]; then
    echo -e "\\nContainer build failed - see build_{bash_container_shortname}.err for details."
    exit 1
else
    echo -e "\\nContainer build appears to have been successful.".
    exit 0
fi
"""
    )
    # fmt: on
    with open(executable_file, "w") as f:
        f.write(executable_contents)

    return submit_file, executable_file


def generate_verbose_text(
    submit_file: str, executable_file: str, args: argparse.Namespace, original_args: dict 
) -> str:
    """
    Generates text with debugging information.
    """

    text_list: list[str] = []

    text_list.append('Original Arguments:')
    for k,v in original_args.items():
        text_list.append(f'    {k}={v}')
    text_list.append('')

    text_list.append('Cleaned Arguments:')
    for k,v in args.__dict__.items():
        text_list.append(f'    {k}={v}')
    text_list.append('')

    text_list.append(
        f"\n    You provided the definition file:\n        {args.definition}"
    )

    if args.files is not None:
        files_list: str = "\n        ".join(args.files)
        text_list.append(
            f"    You also specified these additional files to transfer:\n        {files_list}"
        )

    text_list.append(
        f"    This script generated the files:\n        {submit_file}\n        {executable_file}"
    )

    text_list.append(
        f"    The build job will create a .sif file at:\n        {args.destination}"
    )

    verbose_text = "\n".join(text_list)

    return verbose_text


def interactive_submit(
    submit_file: str, executable_file: str, args: argparse.Namespace
) -> None:
    print(f"\nSubmitting interactive job using '{submit_file}'.\n")

    # Submit interactive job (if that is even possible via a Python script!!)


def regular_submit(
    submit_file: str, executable_file: str, args: argparse.Namespace
) -> None:
    print(f"\nSubmitting regular job using '{submit_file}'.\n")

    # Submit regular job using the Python bindings


def get_args(username: str) -> argparse.Namespace:
    """
    Creates parser for parsing arguments
    """

    # Instantiate parser
    parser_description: str = f"""
        Use this script to generate the files necessary to submit a job for building an Apptainer container.
        """
    parser_epilog: str = f"""
        Version {VERSION} -- 
        This script can be used to create the files needed to submit an HTCondor job to build an Apptainer container 
        on CHTC's High Throughput Computing (HTC) cluster. User provides the necessary Apptainer definition (.def) 
        file and the script will create the necessary submit (.sub) and executable (.sh) files. Once generated, the
        user can use the `condor_submit` command to submit a job that builds the Apptainer container image (.sif). 
        For more information, see <link to CHTC webpage>.
        
        The submit file is set up to automatically transfer the container .sif image to the user's /staging directory,
        unless otherwise specified.
        """

    parser = argparse.ArgumentParser(
        description=parser_description,
        epilog=parser_epilog,
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    # General "optional" arguments

    parser.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        help="Print additional information useful for testing and debugging.",
    )
    parser.add_argument("--version", action="version", version=VERSION)

    # Required arguments

    required = parser.add_argument_group("required")

    required.add_argument(
        "-d",
        "--definition",
        required=True,
        type=str,
        metavar="<name>.def",
        help="Name of Apptainer definition .def file to convert to Apptainer image .sif file.",
    )

    # Additional arguments

    additional = parser.add_argument_group("additional")

    additional.add_argument(
        "-n",
        "--name",
        required=False,
        type=str,
        metavar="<name>.sif",
        default="<name>.sif",
        help="Desired name of the created Apptainer image .sif file.",
    )
    additional.add_argument(
        "-p",
        "--path",
        required=False,
        type=str,
        metavar="<path>",
        default=f"file:///staging/{username}",
        help="Defines a transfer_output_remap that transfers the <name>.sif file to the provided destination.",
    )
    additional.add_argument(
        "-f",
        "--files",
        type=str,
        metavar=("FILE1", "FILE2"),
        nargs="*",
        help="List additional files that will need to be transferred alongside the .def file.",
    )

    # Mutually exclusive additional arguments

    mutually_exclusive = additional.add_mutually_exclusive_group()

    mutually_exclusive.add_argument(
        "-i",
        "--interactive-submit",
        action="store_true",
        help='Specifies an "interactive" job submission. Once started, user will need to manually execute the .sh script.',
    )
    mutually_exclusive.add_argument(
        "-s",
        "--submit",
        action="store_true",
        help="Submit a regular job automatically using the generated submit and executable files.",
    )

    return parser.parse_args()


def main(args: argparse.Namespace) -> None:
    """
    Processes arguments, generates files, and submits Apptainer build
    """

    # Check that argument values are valid, do cleanup
    original_args: dict = {k: v for k,v in args.__dict__.items()}
    args = validate(args)

    # Create necessary files

    submit_file, executable_file = generate_files(args)

    # Verbose text for troubleshooting

    if args.verbose == True:
        verbose_text = generate_verbose_text(submit_file, executable_file, args, original_args)
        print(verbose_text)

    # Submit Apptainer build job

    if args.interactive_submit == True:
        try:
            interactive_submit(submit_file, executable_file, args)
        except Exception as e:
            print(
                f"Unknown exception occurred when attempting interactive job submission: {e}"
            )
    elif args.submit == True:
        try:
            regular_submit(submit_file, executable_file, args)
        except Exception as e:
            print(
                f"Unknown exception occurred when attempting regular job submission: {e}"
            )
    else:
        try:
            print(
                f"\nBuild files generated! User needs to submit a job using `condor_submit {submit_file}`.\n"
            )
        except Exception as e:
            print(
                f"Unknown exception occurred when reporting generated file names: {e}"
            )


if __name__ == "__main__":
    # Get user information
    username: str = str(pwd.getpwuid(os.getuid())[0])

    # Parse arguments
    args = get_args(username)

    # Execute
    main(args)
