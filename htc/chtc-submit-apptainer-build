#!/usr/bin/env python3

# ^-- replace shebang with "#!/usr/bin/python3" before deploying to CHTC.

# Written for Python 3.9

##############
# HTC Submit #
##############

import argparse
import os
import pwd
import subprocess
from time import sleep

VERSION: str = "0.1"
PRINT_DELAY: float = 1.5
PRINT_PREFIX: str = "%"


def validate(args: argparse.Namespace) -> argparse.Namespace:
    """
    Checks that argument values are proper and ready to be used by the rest of the script.
    """

    # Check that `definition` is a valid file
    if not os.path.isfile(args.definition):
        if args.definition[-4:] == ".def":
            raise ValueError(f"Failed to locate definition file: {args.definition}")
        else:
            with_extension: str = f"{args.definition}.def"
            if os.path.isfile(with_extension):
                args.definition = with_extension
            else:
                raise ValueError(
                    f"Failed to locate definition file: {args.definition} NOR {with_extension}"
                )

    # If provided `definition` is a path, make `definition` a basename and put full path in `full_definition`
    args.full_definition = args.definition
    if "/" in args.definition:
        definition_basename: str = args.definition.split("/")[-1]
        args.definition = definition_basename

    # Generate `name` if `name` is not user-defined
    if (args.name is None) or (args.name == "<name>.sif"):
        if args.definition[-4:] == ".def":
            args.name = f"{args.definition[:-4]}.sif"
        else:
            args.name = f"{args.definition}.sif"

    # Check that `name` ends in `.sif`
    if args.name[-4:] != ".sif":
        args.full_name = f"{args.name}.sif"
    else:
        args.full_name = f"{args.name}"
        args.name = args.name[:-4]

    # Check that output destination `path` does not already contain `name`
    overwrite_warning: str = (
        f"WARNING: Output destination (may) already contain {args.full_name} - if so, it will be overwritten by this job!"
    )

    if args.path[-1] == "/":
        args.path = args.path[:-1]

    if args.path[:4] in ["osdf", "peli"]:
        print(overwrite_warning)

    destination = f"{args.path}/{args.full_name}"
    if os.path.isfile(destination):
        print(overwrite_warning)

    args.destination: str = destination

    # Convenient for "ls" reference
    if args.path[:8] == "file:///":
        # Want to keep one slash in the front
        args.path_no_file = args.path[7:]
    elif args.path[:7] == "file://":
        args.path_no_file = args.path[6:]
    else:
        args.path_no_file = str(args.path)

    return args


def generate_files(args: argparse.Namespace) -> tuple[str, str]:
    """
    Generates the files needed in order to submit the build job.
    """

    submit_file: str = "apptainer-build.sub"
    executable_file: str = "apptainer-build.sh"

    file_transfer_list = [args.full_definition, *args.files]
    file_transfer_string = ", ".join([str(i) for i in file_transfer_list])

    # Write `submit_file`
    submit_contents: str = f"""
job_name = build_{args.name}

universe = vanilla
log = $(job_name).log
batch_name = $(job_name)

executable = apptainer-build.sh
transfer_executable = True
arguments = {args.full_name} {args.definition}
transfer_input_files = {file_transfer_string}

transfer_output_files = {args.full_name}, {args.name}.log
transfer_output_remaps = "{args.full_name} = {args.destination}; {args.name}.log = {args.path}/{args.name}.log"

output = $(job_name).out
error = $(job_name).err
stream_output = True
stream_error = True

+IsBuildJob = True

request_cpus = 8
request_memory = 16GB
request_disk = 30GB

queue
"""

    with open(submit_file, "w") as f:
        f.write(submit_contents)

    # Write `executable_file`
    # Following definitions are used to include literal {} in the f-string block
    #   without using escapes (`\`) in the block, which the black formatter does not agree with
    bash_arg1 = "${1}"
    bash_arg2 = "${2}"
    bash_container_name = "${container_name}"
    bash_container_definition = "${container_definition}"
    bash_container_shortname = "${container_name::-4}"

    # fmt: off
    executable_contents: str = (
        f"""#!/bin/bash

# Read arguments from submit file
container_name={bash_arg1}
container_definition={bash_arg2}

# Printing information about the build job
cat << EOF | tee {bash_container_shortname}.log
chtc-apptainer-build-submit

     version: {VERSION}
    datetime: $(date -Iseconds)
  build_host: $(hostname -f)
  definition: {bash_container_definition}
output_image: {bash_container_name}

EOF

# Print copy of definition file (useful for troubleshooting)
cat << EOF | tee -a {bash_container_shortname}.log
#=====================================#
# {bash_container_definition}
#-------------------------------------#
$(cat {bash_container_definition})
#=====================================#

EOF

# Miscellaneous setup things; typically not required, but erring on the safe side.
export PATH
chmod 777 ./tmp

# The actual build command. Piped into `tee` so that messages are streamed to build_{bash_container_shortname}.out
apptainer build --bind ./tmp:/tmp {bash_container_name} {bash_container_definition} 2>&1 | tee -a {bash_container_shortname}.log

# If running the build command manually, could use this instead:
#    apptainer build --bind ./tmp:/tmp {bash_container_name} {bash_container_definition}

# Grab exit code from the build command
exit_code="$PIPESTATUS"

# Check if container built successfully
if [ ! -f "{bash_container_name}" ] || [[ "$exit_code" != "0" ]]; then
    echo -e "\\nContainer build failed - see build_{bash_container_shortname}.err for details." | tee -a {bash_container_shortname}.log
    exit 1
else
    echo -e "\\nContainer build appears to have been successful." | tee -a {bash_container_shortname}.log
    exit 0
fi
"""
    )
    # fmt: on
    with open(executable_file, "w") as f:
        f.write(executable_contents)

    sleep(PRINT_DELAY)
    print(
        f"""
{PRINT_PREFIX} Created submit file "{submit_file}" and executable "{executable_file}".
"""
    )

    return submit_file, executable_file


def generate_verbose_text(
    submit_file: str,
    executable_file: str,
    args: argparse.Namespace,
    original_args: dict,
) -> str:
    """
    Generates text with debugging information.
    """
    sleep(PRINT_DELAY)
    print(
        f"""{PRINT_PREFIX} Printing verbose output:
"""
    )
    sleep(PRINT_DELAY)

    text_list: list[str] = [f"chtc-submit-apptainer-build v{VERSION}\n"]

    text_list.append("Original Arguments:")
    for k, v in original_args.items():
        text_list.append(f"    {k}={v}")
    text_list.append("")

    text_list.append("Cleaned Arguments:")
    for k, v in args.__dict__.items():
        text_list.append(f"    {k}={v}")
    text_list.append("")

    text_list.append(
        f"Summary\n=======\nYou provided the definition file:\n    {args.definition}"
    )

    if args.files is not None:
        files_list: str = "\n    ".join(args.files)
        text_list.append(
            f"You also specified these additional files to transfer:\n    {files_list}"
        )

    text_list.append(
        f"This script generated the files:\n    {submit_file}\n    {executable_file}"
    )

    text_list.append(
        f"The build job will create a .sif file at:\n    {args.destination}"
    )

    text_list.append("")

    verbose_text = "\n".join(text_list)

    return verbose_text


def shell_exec(
    command_list: list[str],
    capture_std: bool = False,
    combined_std: bool = True,
    timeout: int = 30,
) -> subprocess.CompletedProcess:
    """
    Wrapper function for running shell commands
    """

    # Make sure not to run a sudo command using this function
    test_str: str = " ".join([str(i) for i in command_list])
    if "sudo" in test_str.lower():
        raise ValueError('Will not execute a command involing "sudo"')

    # Make sure command is split on white space
    clean_list: list[str] = []
    for i in command_list:
        split_list: list[str] = [s for s in i.split() if not s.isspace() and s != ""]
        if len(split_list) == 0:
            continue
        else:
            clean_list.extend(split_list)

    if capture_std:
        if combined_std:
            exec_command: subprocess.CompletedProcess = subprocess.run(
                clean_list,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                timeout=timeout,
            )
        else:
            exec_command = subprocess.run(
                clean_list,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                timeout=timeout,
            )
    else:
        exec_command = subprocess.run(clean_list, timeout=timeout)

    return exec_command


def byte_to_str(byte_string: bytes, encoding="utf-8") -> str:
    """
    Simplifies converting bytes to str
    """
    return str(byte_string, encoding)


def interactive_submit(
    submit_file: str, executable_file: str, args: argparse.Namespace
) -> None:
    print(f"\nSubmitting interactive job using '{submit_file}'.\n")

    raise NotImplemented("This feature is not yet implemented.")

    # Submit interactive job (if that is even possible via a Python script!!)


def regular_submit(
    submit_file: str, executable_file: str, args: argparse.Namespace
) -> None:
    sleep(PRINT_DELAY)
    print(
        f"""{PRINT_PREFIX} Executing command:
    condor_submit {submit_file}
"""
    )

    # IDEALLY: Submit regular job using the Python bindings.
    # In practice, however, run into the "Job credentials not found" error.
    sleep(PRINT_DELAY)
    try:
        exec_submit_command = shell_exec(
            ["condor_submit", submit_file], timeout=args.timeout
        )
    except subprocess.TimeoutExpired as s:
        raise subprocess.TimeoutExpired(s)

    # print(byte_to_str(exec_submit_command.stdout))

    # Give illusion of "processing"
    sleep(PRINT_DELAY)

    if exec_submit_command.returncode == 0:
        print(
            f"""
{PRINT_PREFIX} Submit command successful!
  - Monitor job status:
      condor_watch_q -f build_{args.name}.log
  - Monitor build progress (after job has started):
      tail -f build_{args.name}.out
  - Once done, find "{args.name}.sif" and "{args.name}.log" in:
      {args.path_no_file}
"""
        )
    else:
        print(
            f"""
{PRINT_PREFIX} Submit command FAILED!
"""
        )


def get_args(username: str) -> argparse.Namespace:
    """
    Creates parser for parsing arguments
    """

    # Instantiate parser
    parser_description: str = f"""
        Use this script to generate the files necessary to submit a job for building an Apptainer container.
        """
    parser_epilog: str = f"""
        Version {VERSION} -- 
        This script can be used to create the files needed to submit an HTCondor job to build an Apptainer container 
        on CHTC's High Throughput Computing (HTC) cluster. User provides the necessary Apptainer definition (.def) 
        file and the script will create the necessary submit (.sub) and executable (.sh) files. Once generated, the
        user can use the `condor_submit` command to submit a job that builds the Apptainer container image (.sif). 
        For more information, see <link to CHTC webpage>.
        
        The submit file is set up to automatically transfer the container .sif image to the user's /staging directory,
        unless otherwise specified.
        """

    parser = argparse.ArgumentParser(
        description=parser_description,
        epilog=parser_epilog,
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    # General "optional" arguments

    parser.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        help="Print additional information useful for testing and debugging.",
    )
    parser.add_argument("--version", action="version", version=VERSION)

    # Required arguments

    required = parser.add_argument_group("required")

    required.add_argument(
        "-d",
        "--definition",
        required=True,
        type=str,
        metavar="<name>.def",
        help="Name of Apptainer definition .def file to convert to Apptainer image .sif file.",
    )

    # Additional arguments

    additional = parser.add_argument_group("additional")

    additional.add_argument(
        "-n",
        "--name",
        required=False,
        type=str,
        metavar="<name>.sif",
        default="<name>.sif",
        help="Desired name of the created Apptainer image .sif file.",
    )
    additional.add_argument(
        "-p",
        "--path",
        required=False,
        type=str,
        metavar="<path>",
        default=f"file:///staging/{username}",
        help="Defines a transfer_output_remap that transfers the <name>.sif file to the provided destination.",
    )
    additional.add_argument(
        "-f",
        "--files",
        type=str,
        metavar=("FILE1", "FILE2"),
        nargs="*",
        help="List additional files that will need to be transferred alongside the .def file.",
    )
    additional.add_argument(
        "-t",
        "--timeout",
        type=int,
        metavar=("SECONDS"),
        default=30,
        help="How long to wait before giving up on submit command.",
    )

    # Mutually exclusive additional arguments

    mutually_exclusive = additional.add_mutually_exclusive_group()

    mutually_exclusive.add_argument(
        "-i",
        "--interactive-submit",
        action="store_true",
        help='Specifies an "interactive" job submission. Once started, user will need to manually execute the .sh script.',
    )
    mutually_exclusive.add_argument(
        "-s",
        "--submit",
        action="store_true",
        help="Submit a regular job automatically using the generated submit and executable files.",
    )

    return parser.parse_args()


def main(args: argparse.Namespace) -> None:
    """
    Processes arguments, generates files, and submits Apptainer build
    """

    # Check that argument values are valid, do cleanup
    original_args: dict = {k: v for k, v in args.__dict__.items()}
    args = validate(args)

    # Create necessary files

    submit_file, executable_file = generate_files(args)

    # Verbose text for troubleshooting

    if args.verbose == True:
        verbose_text = generate_verbose_text(
            submit_file, executable_file, args, original_args
        )
        print(verbose_text)

    # Submit Apptainer build job

    if args.interactive_submit == True:
        try:
            interactive_submit(submit_file, executable_file, args)
        except Exception as e:
            print(
                f"Unknown exception occurred when attempting interactive job submission: {e}"
            )
    elif args.submit == True:
        try:
            regular_submit(submit_file, executable_file, args)
        except subprocess.TimeoutExpired:
            print(f"Error: Submit command timed out after {args.timeout} seconds.")
        except Exception as e:
            print(
                f"Unknown exception occurred when attempting regular job submission: {e}"
            )
    else:
        try:
            sleep(PRINT_DELAY)
            print(
                f"""{PRINT_PREFIX} Done! Submit the Apptainer build job to HTCondor using:
    condor_submit {submit_file}
"""
            )
        except Exception as e:
            print(
                f"Unknown exception occurred when reporting generated file names: {e}"
            )

    sleep(PRINT_DELAY)


if __name__ == "__main__":
    # Get user information
    username: str = str(pwd.getpwuid(os.getuid())[0])

    # Parse arguments
    args = get_args(username)

    # Execute
    main(args)
